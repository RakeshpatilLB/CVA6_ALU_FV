module props 
  import ariane_pkg::*;
  import pmp_formal_pkg::*;

#(
    //parameter config_pkg::cva6_cfg_t CVA6Cfg       = config_pkg::cva6_cfg_empty,
    parameter config_pkg::cva6_cfg_t CVA6Cfg = build_config_pkg::build_config(cva6_config_pkg::cva6_cfg), // <--- Modified line
    //parameter type                   icache_areq_t = logic,
    parameter type                   icache_areq_t = pmp_formal_pkg::icache_areq_t,
    //parameter type                   exception_t   = logic
    parameter type                   exception_t = pmp_formal_pkg::exception_t
) 


(
    
    input logic clk_i,
    input logic rst_ni,
    // IF interface
    input icache_areq_t icache_areq_i,
    input icache_areq_t icache_areq_o,
    input [CVA6Cfg.VLEN-1:0] icache_fetch_vaddr_i,  // virtual address for tval only
    // LSU interface
    // this is a more minimalistic interface because the actual addressing logic is handled
    // in the LSU as we distinguish load and stores, what we do here is simple address translation
    input logic lsu_valid_i,  // request lsu access
    input logic [CVA6Cfg.PLEN-1:0] lsu_paddr_i,  // physical address in
    input logic [CVA6Cfg.VLEN-1:0] lsu_vaddr_i,  // virtual address in, for tval only
    input exception_t lsu_exception_i,  // lsu exception coming from MMU, or misaligned exception
    input logic lsu_is_store_i,  // the translation is requested by a store
    input logic lsu_valid_o,  // translation is valid
    input logic [CVA6Cfg.PLEN-1:0] lsu_paddr_o,  // translated address
    input exception_t lsu_exception_o,  // address translation threw an exception
    // General control signals
    input riscv::priv_lvl_t priv_lvl_i,
    input logic v_i,
    input riscv::priv_lvl_t ld_st_priv_lvl_i,
    input logic ld_st_v_i,
    // PMP
    input riscv::pmpcfg_t [avoid_neg(CVA6Cfg.NrPMPEntries-1):0] pmpcfg_i,
    input logic [avoid_neg(CVA6Cfg.NrPMPEntries-1):0][CVA6Cfg.PLEN-3:0] pmpaddr_i);



rst_ni_stable: assume property ( !$isunknown(rst_ni));

legal_usermodes_1: assume property ( priv_lvl_i inside {riscv::PRIV_LVL_U, riscv::PRIV_LVL_S, riscv::PRIV_LVL_M});
legal_usermodes_2: assume property ( ld_st_priv_lvl_i inside {riscv::PRIV_LVL_U, riscv::PRIV_LVL_S, riscv::PRIV_LVL_M});

lsu_paddr_i_stable: assume property ( !$isunknown(lsu_paddr_i));
pmpcfg_i_stable: assume property ( !$isunknown(pmpcfg_i));



// Known-value assumptions on all DUT inputs


// IF interface
assume property ( !$isunknown(icache_areq_i));
assume property ( !$isunknown(icache_areq_o));
assume property ( !$isunknown(icache_fetch_vaddr_i));

// LSU interface
assume property ( !$isunknown(lsu_valid_i));
assume property ( !$isunknown(lsu_paddr_i));
assume property ( !$isunknown(lsu_vaddr_i));
assume property ( !$isunknown(lsu_exception_i));
assume property ( !$isunknown(lsu_is_store_i));
assume property ( !$isunknown(lsu_valid_o));
assume property ( !$isunknown(lsu_paddr_o));
assume property ( !$isunknown(lsu_exception_o));

// General control signals
assume property ( !$isunknown(priv_lvl_i));
assume property ( !$isunknown(v_i));
assume property ( !$isunknown(ld_st_priv_lvl_i));
assume property ( !$isunknown(ld_st_v_i));

// PMP
assume property ( !$isunknown(pmpcfg_i));
assume property ( !$isunknown(pmpaddr_i));
																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																												
genvar i;
generate
for(i=0;i<8;i++) begin :addr_mode
assume property (pmpcfg_i[i].addr_mode inside{riscv::OFF, riscv::TOR}); //add NAPOT later
end
endgenerate

genvar k;
generate
  for (k = 1; k < 8; k++) begin : tor_ordering
    assume property (
      (pmpcfg_i[k].addr_mode == riscv::TOR) |-> (pmpaddr_i[k] > pmpaddr_i[k-1]));
  end
endgenerate



//covers
priv_levl_i:cover property((priv_lvl_i==riscv::PRIV_LVL_U) || (priv_lvl_i==riscv::PRIV_LVL_S) || (priv_lvl_i==riscv::PRIV_LVL_M));
priv_levl_d: cover property((ld_st_priv_lvl_i==riscv::PRIV_LVL_U) || (ld_st_priv_lvl_i==riscv::PRIV_LVL_S) || (ld_st_priv_lvl_i==riscv::PRIV_LVL_M));


//addr_modes: cover property((addr_mode == riscv::TOR) || (addr_mode == riscv::OFF));
genvar m;
generate
for(m=0;m<8;m++) begin :addr_modes
cover property (pmpcfg_i[m].addr_mode==riscv::OFF || pmpcfg_i[m].addr_mode==riscv::TOR); //add NAPOT later
end
endgenerate

c1:cover property ( lsu_valid_i);
c2:cover property ( lsu_valid_i && !lsu_is_store_i);
c3:cover property ( lsu_valid_i && !lsu_is_store_i &&
                                     priv_lvl_i != riscv::PRIV_LVL_M);

c4:cover property ((lsu_valid_i)&& (!lsu_is_store_i)&&(ld_st_priv_lvl_i !=riscv::PRIV_LVL_M) &&(pmp_data_if.i_pmp_data.gen_pmp.match==8'b10000000));

//assertions:


//when physical address is not in executable address range, throw INSTR_ACCESS_FAULT exception.
is_inside_execute_region : assert property(!(config_pkg::is_inside_execute_regions(CVA6Cfg, {{64 - CVA6Cfg.PLEN{1'b0}}, icache_areq_i.fetch_paddr})) |->(icache_areq_o.fetch_exception.cause == riscv::INSTR_ACCESS_FAULT)&& (icache_areq_o.fetch_exception.valid)); 

//for instruction fetch :least entry that matches the address region should get the grant (if in U or S mode)
least_index_match_if_0: assert property((!lsu_valid_i) &&(priv_lvl_i !=riscv::PRIV_LVL_M) &&(pmp_data_if.i_pmp_if.gen_pmp.match==8'b???????1)&&(!pmpcfg_i[0].access_type.x) |->(icache_areq_o.fetch_exception.cause == riscv::INSTR_ACCESS_FAULT)&& (icache_areq_o.fetch_exception.valid));

least_index_match_if_1: assert property((!lsu_valid_i) &&(priv_lvl_i !=riscv::PRIV_LVL_M) &&(pmp_data_if.i_pmp_if.gen_pmp.match==8'b??????10)&&(!pmpcfg_i[1].access_type.x) |->(icache_areq_o.fetch_exception.cause == riscv::INSTR_ACCESS_FAULT)&& (icache_areq_o.fetch_exception.valid));

least_index_match_if_2: assert property((!lsu_valid_i) &&(priv_lvl_i !=riscv::PRIV_LVL_M) &&(pmp_data_if.i_pmp_if.gen_pmp.match==8'b?????100)&&(!pmpcfg_i[2].access_type.x) |->(icache_areq_o.fetch_exception.cause == riscv::INSTR_ACCESS_FAULT)&& (icache_areq_o.fetch_exception.valid));

least_index_match_if_3: assert property((!lsu_valid_i) &&(priv_lvl_i !=riscv::PRIV_LVL_M) &&(pmp_data_if.i_pmp_if.gen_pmp.match==8'b????1000)&&(!pmpcfg_i[3].access_type.x) |->(icache_areq_o.fetch_exception.cause == riscv::INSTR_ACCESS_FAULT)&& (icache_areq_o.fetch_exception.valid));

least_index_match_if_4: assert property((!lsu_valid_i) &&(priv_lvl_i !=riscv::PRIV_LVL_M) &&(pmp_data_if.i_pmp_if.gen_pmp.match==8'b???10000)&&(!pmpcfg_i[4].access_type.x) |->(icache_areq_o.fetch_exception.cause == riscv::INSTR_ACCESS_FAULT)&& (icache_areq_o.fetch_exception.valid));

least_index_match_if_5: assert property((!lsu_valid_i) &&(priv_lvl_i !=riscv::PRIV_LVL_M) &&(pmp_data_if.i_pmp_if.gen_pmp.match==8'b??100000)&&(!pmpcfg_i[5].access_type.x) |->(icache_areq_o.fetch_exception.cause == riscv::INSTR_ACCESS_FAULT)&& (icache_areq_o.fetch_exception.valid));

least_index_match_if_6: assert property((!lsu_valid_i) &&(priv_lvl_i !=riscv::PRIV_LVL_M) &&(pmp_data_if.i_pmp_if.gen_pmp.match==8'b?1000000)&&(!pmpcfg_i[6].access_type.x) |->(icache_areq_o.fetch_exception.cause == riscv::INSTR_ACCESS_FAULT)&& (icache_areq_o.fetch_exception.valid));

least_index_match_if_7: assert property((!lsu_valid_i) &&(priv_lvl_i !=riscv::PRIV_LVL_M) &&(pmp_data_if.i_pmp_if.gen_pmp.match==8'b10000000)&&(!pmpcfg_i[7].access_type.x) |->(icache_areq_o.fetch_exception.cause == riscv::INSTR_ACCESS_FAULT)&& (icache_areq_o.fetch_exception.valid));

//least index matching during load store

least_index_match_data: assert property((lsu_valid_i)&& (!lsu_is_store_i)&&(ld_st_priv_lvl_i !=riscv::PRIV_LVL_M) &&(pmp_data_if.i_pmp_data.gen_pmp.match==8'b10000000)&&(!pmpcfg_i[7].access_type.r)|->((lsu_exception_o.cause == riscv::LD_ACCESS_FAULT)&& (lsu_exception_o.valid)));



endmodule

bind pmp_data_if props sva_inst_i(.clk_i(clk_i),
  .rst_ni(rst_ni),
  .icache_areq_i(icache_areq_i),
  .icache_areq_o(icache_areq_o),
  .icache_fetch_vaddr_i(icache_fetch_vaddr_i),

  .lsu_valid_i(lsu_valid_i),
  .lsu_paddr_i(lsu_paddr_i),
  .lsu_vaddr_i(lsu_vaddr_i),
  .lsu_exception_i(lsu_exception_i),
  .lsu_is_store_i(lsu_is_store_i),
  .lsu_valid_o(lsu_valid_o),
  .lsu_paddr_o(lsu_paddr_o),
  .lsu_exception_o(lsu_exception_o),
  .priv_lvl_i(priv_lvl_i),
  .v_i(v_i),
  .ld_st_priv_lvl_i(ld_st_priv_lvl_i),
  .ld_st_v_i(ld_st_v_i),
  .pmpcfg_i(pmpcfg_i),
  .pmpaddr_i(pmpaddr_i)

);











